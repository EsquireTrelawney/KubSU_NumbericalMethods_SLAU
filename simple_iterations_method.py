import numpy as np

# Метод простых итераций
# Принимает на вход матрицу коэфф, вектор свободных коэфф, начальное приближение, макс кол-во итераций и погрешность
def simple_iterations_solve(matrix, column_vector, max_iterations, epsilon):
    x0 = np.zeros_like(column_vector) # создаём вектор с начальным приближением решения. Нуль-вектор с таким же кол-вом #
                                     # ... элементов, что и у вектора свободных коэфф
    iteration_num = 0
    # Получение размера матрицы
    n = len(matrix)

    # Создание нулевой матрицы для хранения новых значений x
    # Размерность у неё будет такая же, как и у вектора начальных приближений. Изначально в векторе нули
    x_new = np.zeros_like(column_vector)

    # Итерации
    for k in range(max_iterations):
        # обращаемся к глобальной переменной для подсчёта кол-ва итераций
        iteration_num += 1
        # Рассчитываем новые значения x по формуле простых итераций, пока не достигнем значения макс итераций
        # Для каждой переменной в системе
        for i in range(n):
            # Создаём переменную для накопления суммы произведений коэффициентов и текущих значения неизвестных
            # ... за исключением той i-ой переменной, для которой вычисляем новое значение
            sigma = 0
            # В этом цикле происходит сам расчёт с исключением слагаемого с переменной на главной диагонали
            for j in range(n):
                if j != i:
                    sigma += matrix[i][j] * x0[j]
            # Завершив суммирование, вычисляем новое значение i-ой переменной по формуле итерации
            x_new[i] = (column_vector[i] - sigma) / matrix[i][i]

        # Проверка на сходимость путём вычисления Евклидовой нормы разности начального приближения и полученного решения
        # ... если норма меньше заданной погрешности, то возвращаем решение как приближенное решение
        if np.linalg.norm(x_new - x0) < epsilon:
            return x_new, iteration_num

        # Обновление значений x0 для следующей итерации
        x0 = np.copy(x_new)

    # В случае, если не достигнута сходимость за указанное количество итераций
    else:
        return x_new, (" - Имеющееся решение. Метод простых итераций не сошёлся за указанное число итераций. \n Возможно, матрица не диагонально-доминирующая. ")